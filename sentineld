#!/usr/bin/env python3
#
# This file is part of the Robotic Observatory Control Kit (rockit)
#
# rockit is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# rockit is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with rockit.  If not, see <http://www.gnu.org/licenses/>.

import datetime
import threading
import urllib.request
import Pyro4
import xml.etree.ElementTree as ET
from rockit.common import daemons, log

SENTINEL_URI = 'http://10.2.5.16:5000/status'
QUERY_TIMEOUT = 3

# pylint: disable=broad-except
# pylint: disable=too-few-public-methods


class SentinelDaemon:
    """Wraps a web request to NGTS Sentinel"""
    def __init__(self):
        self._query_error = False

        self._lock = threading.Lock()
        self._last_measurement_date = None
        self._last_measurement = None

    @Pyro4.expose
    def last_measurement(self):
        """Query the latest valid measurement.
        May return None if no data is available"""
        now = datetime.datetime.now(datetime.timezone.utc)

        # Rate limit queries to once per 10 seconds
        if self._last_measurement_date and (now - self._last_measurement_date).total_seconds() < 10:
            with self._lock:
                return self._last_measurement

        try:
            with urllib.request.urlopen(SENTINEL_URI, timeout=QUERY_TIMEOUT) as response:
                sentinel_string = response.read()
                tree = ET.fromstring(sentinel_string)

            # work out timestamp of data
            date = datetime.datetime.strptime(tree.find('./weather/tsample').text, '%Y-%m-%d %H:%M:%S')

            # combine rg11 sensors
            rg11_total = 0
            rg11s = [1, 2, 4]  # Only some of the sensors are connected
            for r in rg11s:
                rg11_total += int(tree.find(f'./weather/rg11_{r:02d}').text)
            rg11_unsafe = 1 if rg11_total > 0 else 0

            # determine roof status
            roof_state = tree.find('./roof/state').text
            if roof_state == "FULL CLOSED":
                closed = True
            else:
                closed = False

            ret = {
                "date": date.strftime('%Y-%m-%dT%H:%M:%SZ'),
                "wind_dir": float(tree.find('./weather/wind_dir').text),
                "wind_dir_valid": True,
                "wind_speed": float(tree.find('./weather/wind_speed_avg').text),
                "wind_speed_valid": True,
                "temperature": float(tree.find('./weather/temperature').text),
                "temperature_valid": True,
                "relative_humidity": float(tree.find('./weather/humidity').text),
                "relative_humidity_valid": True,
                "pressure": float(tree.find('./weather/pressure').text),
                "pressure_valid": True,
                "dew_point_delta": float(tree.find('./weather/dew_point_margin').text),
                "dew_point_delta_valid": True,
                "rg11_unsafe": rg11_unsafe,
                "rg11_unsafe_valid": True,
                "rg11_total": len(rg11s),
                "rg11_total_valid": True,
                "dust_large": float(tree.find('./weather/dust_large').text),
                "dust_large_valid": True,
                "dust_small": float(tree.find('./weather/dust_small').text),
                "dust_small_valid": True,
                "light": float(tree.find('./weather/light').text),
                "light_valid": True,
                "sky_temperature": float(tree.find('./weather/sky_temperature').text),
                "sky_temperature_valid": True,
                "roof_state": roof_state,
                "roof_closed": closed
            }

            if self._query_error:
                log.info('sentineld', 'Restored contact with Sentinel')
                self._query_error = False

            with self._lock:
                self._last_measurement_date = now
                self._last_measurement = ret

            return ret
        except Exception as exception:
            print(f'{now} ERROR: failed to query from Sentinel: {exception}')

            if not self._query_error:
                log.error('sentineld', 'Lost contact with Sentinel')
                self._query_error = True

            return None


if __name__ == '__main__':
    daemons.ngts_sentinel.launch(SentinelDaemon())
